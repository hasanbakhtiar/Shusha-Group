{"ast":null,"code":"import e from \"void-elements\";\nvar t = /\\s([^'\"/\\s><]+?)[\\s/>]|([^\\s=]+)=\\s?(\".*?\"|'.*?')/g;\nfunction n(n) {\n  var r = {\n      type: \"tag\",\n      name: \"\",\n      voidElement: !1,\n      attrs: {},\n      children: []\n    },\n    i = n.match(/<\\/?([^\\s]+?)[/\\s>]/);\n  if (i && (r.name = i[1], (e[i[1]] || \"/\" === n.charAt(n.length - 2)) && (r.voidElement = !0), r.name.startsWith(\"!--\"))) {\n    var s = n.indexOf(\"--\\x3e\");\n    return {\n      type: \"comment\",\n      comment: -1 !== s ? n.slice(4, s) : \"\"\n    };\n  }\n  for (var a = new RegExp(t), c = null; null !== (c = a.exec(n));) if (c[0].trim()) if (c[1]) {\n    var o = c[1].trim(),\n      l = [o, \"\"];\n    o.indexOf(\"=\") > -1 && (l = o.split(\"=\")), r.attrs[l[0]] = l[1], a.lastIndex--;\n  } else c[2] && (r.attrs[c[2]] = c[3].trim().substring(1, c[3].length - 1));\n  return r;\n}\nvar r = /<[a-zA-Z0-9\\-\\!\\/](?:\"[^\"]*\"|'[^']*'|[^'\">])*>/g,\n  i = /^\\s*$/,\n  s = Object.create(null);\nfunction a(e, t) {\n  switch (t.type) {\n    case \"text\":\n      return e + t.content;\n    case \"tag\":\n      return e += \"<\" + t.name + (t.attrs ? function (e) {\n        var t = [];\n        for (var n in e) t.push(n + '=\"' + e[n] + '\"');\n        return t.length ? \" \" + t.join(\" \") : \"\";\n      }(t.attrs) : \"\") + (t.voidElement ? \"/>\" : \">\"), t.voidElement ? e : e + t.children.reduce(a, \"\") + \"</\" + t.name + \">\";\n    case \"comment\":\n      return e + \"\\x3c!--\" + t.comment + \"--\\x3e\";\n  }\n}\nvar c = {\n  parse: function (e, t) {\n    t || (t = {}), t.components || (t.components = s);\n    var a,\n      c = [],\n      o = [],\n      l = -1,\n      m = !1;\n    if (0 !== e.indexOf(\"<\")) {\n      var u = e.indexOf(\"<\");\n      c.push({\n        type: \"text\",\n        content: -1 === u ? e : e.substring(0, u)\n      });\n    }\n    return e.replace(r, function (r, s) {\n      if (m) {\n        if (r !== \"</\" + a.name + \">\") return;\n        m = !1;\n      }\n      var u,\n        f = \"/\" !== r.charAt(1),\n        h = r.startsWith(\"\\x3c!--\"),\n        p = s + r.length,\n        d = e.charAt(p);\n      if (h) {\n        var v = n(r);\n        return l < 0 ? (c.push(v), c) : ((u = o[l]).children.push(v), c);\n      }\n      if (f && (l++, \"tag\" === (a = n(r)).type && t.components[a.name] && (a.type = \"component\", m = !0), a.voidElement || m || !d || \"<\" === d || a.children.push({\n        type: \"text\",\n        content: e.slice(p, e.indexOf(\"<\", p))\n      }), 0 === l && c.push(a), (u = o[l - 1]) && u.children.push(a), o[l] = a), (!f || a.voidElement) && (l > -1 && (a.voidElement || a.name === r.slice(2, -1)) && (l--, a = -1 === l ? c : o[l]), !m && \"<\" !== d && d)) {\n        u = -1 === l ? c : o[l].children;\n        var x = e.indexOf(\"<\", p),\n          g = e.slice(p, -1 === x ? void 0 : x);\n        i.test(g) && (g = \" \"), (x > -1 && l + u.length >= 0 || \" \" !== g) && u.push({\n          type: \"text\",\n          content: g\n        });\n      }\n    }), c;\n  },\n  stringify: function (e) {\n    return e.reduce(function (e, t) {\n      return e + a(\"\", t);\n    }, \"\");\n  }\n};\nexport default c;","map":{"version":3,"mappings":"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","names":["attrRE","stringify","tag","res","type","name","voidElement","attrs","children","tagMatch","match","lookup","charAt","length","startsWith","endIndex","indexOf","comment","slice","reg","RegExp","result","exec","trim","attr","arr","split","lastIndex","substring","tagRE","whitespaceRE","empty","Object","create","buff","doc","content","key","push","join","attrString","reduce","parse","html","options","components","current","level","inComponent","end","replace","index","parent","isOpen","isComment","start","nextChar","parseTag","undefined","test","token","rootEl"],"sources":["/home/hasanbakhtiar/Desktop/Shusha-Group/ReactJS/lesson11-multiLangMode/node_modules/html-parse-stringify/src/parse-tag.js","/home/hasanbakhtiar/Desktop/Shusha-Group/ReactJS/lesson11-multiLangMode/node_modules/html-parse-stringify/src/parse.js","/home/hasanbakhtiar/Desktop/Shusha-Group/ReactJS/lesson11-multiLangMode/node_modules/html-parse-stringify/src/stringify.js","/home/hasanbakhtiar/Desktop/Shusha-Group/ReactJS/lesson11-multiLangMode/node_modules/html-parse-stringify/src/index.js"],"sourcesContent":["import lookup from 'void-elements'\nconst attrRE = /\\s([^'\"/\\s><]+?)[\\s/>]|([^\\s=]+)=\\s?(\".*?\"|'.*?')/g\n\nexport default function stringify(tag) {\n  const res = {\n    type: 'tag',\n    name: '',\n    voidElement: false,\n    attrs: {},\n    children: [],\n  }\n\n  const tagMatch = tag.match(/<\\/?([^\\s]+?)[/\\s>]/)\n  if (tagMatch) {\n    res.name = tagMatch[1]\n    if (\n      lookup[tagMatch[1]] ||\n      tag.charAt(tag.length - 2) === '/'\n    ) {\n      res.voidElement = true\n    }\n\n    // handle comment tag\n    if (res.name.startsWith('!--')) {\n      const endIndex = tag.indexOf('-->')\n      return {\n        type: 'comment',\n        comment: endIndex !== -1 ? tag.slice(4, endIndex) : '',\n      }\n    }\n  }\n\n  const reg = new RegExp(attrRE)\n  let result = null\n  for (;;) {\n    result = reg.exec(tag)\n\n    if (result === null) {\n      break\n    }\n\n    if (!result[0].trim()) {\n      continue\n    }\n\n    if (result[1]) {\n      const attr = result[1].trim()\n      let arr = [attr, '']\n\n      if (attr.indexOf('=') > -1) {\n        arr = attr.split('=')\n      }\n\n      res.attrs[arr[0]] = arr[1]\n      reg.lastIndex--\n    } else if (result[2]) {\n      res.attrs[result[2]] = result[3].trim().substring(1, result[3].length - 1)\n    }\n  }\n\n  return res\n}\n","import parseTag from './parse-tag'\n\nconst tagRE = /<[a-zA-Z0-9\\-\\!\\/](?:\"[^\"]*\"|'[^']*'|[^'\">])*>/g\nconst whitespaceRE = /^\\s*$/\n\n// re-used obj for quick lookups of components\nconst empty = Object.create(null)\n\nexport default function parse(html, options) {\n  options || (options = {})\n  options.components || (options.components = empty)\n  const result = []\n  const arr = []\n  let current\n  let level = -1\n  let inComponent = false\n\n  // handle text at top level\n  if (html.indexOf('<') !== 0) {\n    var end = html.indexOf('<')\n    result.push({\n      type: 'text',\n      content: end === -1 ? html : html.substring(0, end),\n    })\n  }\n\n  html.replace(tagRE, function (tag, index) {\n    if (inComponent) {\n      if (tag !== '</' + current.name + '>') {\n        return\n      } else {\n        inComponent = false\n      }\n    }\n    const isOpen = tag.charAt(1) !== '/'\n    const isComment = tag.startsWith('<!--')\n    const start = index + tag.length\n    const nextChar = html.charAt(start)\n    let parent\n\n    if (isComment) {\n      const comment = parseTag(tag)\n\n      // if we're at root, push new base node\n      if (level < 0) {\n        result.push(comment)\n        return result\n      }\n      parent = arr[level]\n      parent.children.push(comment)\n      return result\n    }\n\n    if (isOpen) {\n      level++\n\n      current = parseTag(tag)\n      if (current.type === 'tag' && options.components[current.name]) {\n        current.type = 'component'\n        inComponent = true\n      }\n\n      if (\n        !current.voidElement &&\n        !inComponent &&\n        nextChar &&\n        nextChar !== '<'\n      ) {\n        current.children.push({\n          type: 'text',\n          content: html.slice(start, html.indexOf('<', start)),\n        })\n      }\n\n      // if we're at root, push new base node\n      if (level === 0) {\n        result.push(current)\n      }\n\n      parent = arr[level - 1]\n\n      if (parent) {\n        parent.children.push(current)\n      }\n\n      arr[level] = current\n    }\n\n    if (!isOpen || current.voidElement) {\n      if (\n        level > -1 &&\n        (current.voidElement || current.name === tag.slice(2, -1))\n      ) {\n        level--\n        // move current up a level to match the end tag\n        current = level === -1 ? result : arr[level]\n      }\n      if (!inComponent && nextChar !== '<' && nextChar) {\n        // trailing text node\n        // if we're at the root, push a base text node. otherwise add as\n        // a child to the current node.\n        parent = level === -1 ? result : arr[level].children\n\n        // calculate correct end of the content slice in case there's\n        // no tag after the text node.\n        const end = html.indexOf('<', start)\n        let content = html.slice(start, end === -1 ? undefined : end)\n        // if a node is nothing but whitespace, collapse it as the spec states:\n        // https://www.w3.org/TR/html4/struct/text.html#h-9.1\n        if (whitespaceRE.test(content)) {\n          content = ' '\n        }\n        // don't add whitespace-only text nodes if they would be trailing text nodes\n        // or if they would be leading whitespace-only text nodes:\n        //  * end > -1 indicates this is not a trailing text node\n        //  * leading node is when level is -1 and parent has length 0\n        if ((end > -1 && level + parent.length >= 0) || content !== ' ') {\n          parent.push({\n            type: 'text',\n            content: content,\n          })\n        }\n      }\n    }\n  })\n\n  return result\n}\n","function attrString(attrs) {\n  const buff = []\n  for (let key in attrs) {\n    buff.push(key + '=\"' + attrs[key] + '\"')\n  }\n  if (!buff.length) {\n    return ''\n  }\n  return ' ' + buff.join(' ')\n}\n\nfunction stringify(buff, doc) {\n  switch (doc.type) {\n    case 'text':\n      return buff + doc.content\n    case 'tag':\n      buff +=\n        '<' +\n        doc.name +\n        (doc.attrs ? attrString(doc.attrs) : '') +\n        (doc.voidElement ? '/>' : '>')\n      if (doc.voidElement) {\n        return buff\n      }\n      return buff + doc.children.reduce(stringify, '') + '</' + doc.name + '>'\n    case 'comment':\n      buff += '<!--' + doc.comment + '-->'\n      return buff\n  }\n}\n\nexport default function (doc) {\n  return doc.reduce(function (token, rootEl) {\n    return token + stringify('', rootEl)\n  }, '')\n}\n","import parse from './parse'\nimport stringify from './stringify'\n\nexport default {\n  parse,\n  stringify,\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}